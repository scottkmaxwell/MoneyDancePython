import typing
import java.io
import java.lang
import org.antlr.runtime
import org.antlr.runtime.tree


class DebugEventListener:
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def commence(self) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def enterAlt(self, i: int) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def errorNode(self, o: object) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def mark(self, i: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def rewind(self) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    def terminate(self) -> None: ...
    
    
class BlankDebugEventListener(DebugEventListener):
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def commence(self) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def enterAlt(self, i: int) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def errorNode(self, o: object) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def mark(self, i: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def rewind(self) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    def terminate(self) -> None: ...
    
    
class DebugEventHub(DebugEventListener):
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self, debugEventListener: DebugEventListener) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def addListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def commence(self) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def enterAlt(self, i: int) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def errorNode(self, o: object) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def mark(self, i: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def rewind(self) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    def terminate(self) -> None: ...
    
    
class DebugEventRepeater(DebugEventListener):
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self, debugEventListener: DebugEventListener) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def commence(self) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def enterAlt(self, i: int) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def errorNode(self, o: object) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def mark(self, i: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def rewind(self) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    def terminate(self) -> None: ...
    
    
class DebugEventSocketProxy(BlankDebugEventListener):
    DEFAULT_DEBUGGER_PORT = 49100
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self, o: org.antlr.runtime.BaseRecognizer, o2: org.antlr.runtime.tree.TreeAdaptor) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def commence(self) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def enterAlt(self, i: int) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def errorNode(self, o: object) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def getTreeAdaptor(self) -> org.antlr.runtime.tree.TreeAdaptor: ...
    
    def handshake(self) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def mark(self, i: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def rewind(self) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    def setTreeAdaptor(self, o: org.antlr.runtime.tree.TreeAdaptor) -> None: ...
    
    def terminate(self) -> None: ...
    
    
class DebugParser(org.antlr.runtime.Parser):
    DEFAULT_TOKEN_CHANNEL = 0
    HIDDEN = 99
    INITIAL_FOLLOW_STACK_SIZE = 100
    MEMO_RULE_FAILED = -2
    MEMO_RULE_UNKNOWN = -1
    NEXT_TOKEN_RULE_NAME = u'nextToken'
    input: org.antlr.runtime.TokenStream
    isCyclicDecision: bool
    
    def __init__(self, o: org.antlr.runtime.TokenStream, o2: org.antlr.runtime.RecognizerSharedState) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def getDebugListener(self) -> DebugEventListener: ...
    
    def reportError(self, j: java.io.IOException) -> None: ...
    
    def setDebugListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    
class DebugTokenStream(org.antlr.runtime.TokenStream):
    input: org.antlr.runtime.TokenStream
    
    def LA(self, i: int) -> int: ...
    
    def LT(self, i: int) -> org.antlr.runtime.Token: ...
    
    def __init__(self, o: org.antlr.runtime.TokenStream, debugEventListener: DebugEventListener) -> None: ...
    
    def consume(self) -> None: ...
    
    def get(self, i: int) -> org.antlr.runtime.Token: ...
    
    def getSourceName(self) -> str: ...
    
    def getTokenSource(self) -> org.antlr.runtime.TokenSource: ...
    
    def index(self) -> int: ...
    
    def mark(self) -> int: ...
    
    def release(self, i: int) -> None: ...
    
    def rewind(self) -> None: ...
    
    def seek(self, i: int) -> None: ...
    
    def setDebugListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    def size(self) -> int: ...
    
    def toString(self) -> str: ...
    
    
class DebugTreeAdaptor(org.antlr.runtime.tree.TreeAdaptor):
    def __init__(self, debugEventListener: DebugEventListener, o: org.antlr.runtime.tree.TreeAdaptor) -> None: ...
    
    def addChild(self, o: object, o2: org.antlr.runtime.Token) -> None: ...
    
    def becomeRoot(self, o: org.antlr.runtime.Token, o2: object) -> object: ...
    
    def create(self, o: org.antlr.runtime.Token) -> object: ...
    
    def deleteChild(self, o: object, i: int) -> object: ...
    
    def dupNode(self, o: object) -> object: ...
    
    def dupTree(self, o: object) -> object: ...
    
    def errorNode(self, o: org.antlr.runtime.TokenStream, o2: org.antlr.runtime.Token, o3: org.antlr.runtime.Token, o4: org.antlr.runtime.RecognitionException) -> object: ...
    
    def getChild(self, o: object, i: int) -> object: ...
    
    def getChildCount(self, o: object) -> int: ...
    
    def getChildIndex(self, o: object) -> int: ...
    
    def getDebugListener(self) -> DebugEventListener: ...
    
    def getParent(self, o: object) -> object: ...
    
    def getText(self, o: object) -> str: ...
    
    def getToken(self, o: object) -> org.antlr.runtime.Token: ...
    
    def getTokenStartIndex(self, o: object) -> int: ...
    
    def getTokenStopIndex(self, o: object) -> int: ...
    
    def getTreeAdaptor(self) -> org.antlr.runtime.tree.TreeAdaptor: ...
    
    def getType(self, o: object) -> int: ...
    
    def getUniqueID(self, o: object) -> int: ...
    
    def isNil(self, o: object) -> bool: ...
    
    def nil(self) -> object: ...
    
    def replaceChildren(self, o: object, i: int, i2: int, o2: object) -> None: ...
    
    def rulePostProcessing(self, o: object) -> object: ...
    
    def setChild(self, o: object, i: int, o2: object) -> None: ...
    
    def setChildIndex(self, o: object, i: int) -> None: ...
    
    def setDebugListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    def setParent(self, o: object, o2: object) -> None: ...
    
    def setText(self, o: object, s: str) -> None: ...
    
    def setTokenBoundaries(self, o: object, o2: org.antlr.runtime.Token, o3: org.antlr.runtime.Token) -> None: ...
    
    def setType(self, o: object, i: int) -> None: ...
    
    
class DebugTreeNodeStream(org.antlr.runtime.tree.TreeNodeStream):
    def LA(self, i: int) -> int: ...
    
    def LT(self, i: int) -> object: ...
    
    def __init__(self, o: org.antlr.runtime.tree.TreeNodeStream, debugEventListener: DebugEventListener) -> None: ...
    
    def consume(self) -> None: ...
    
    def get(self, i: int) -> object: ...
    
    def getSourceName(self) -> str: ...
    
    def getTokenStream(self) -> org.antlr.runtime.TokenStream: ...
    
    def getTreeAdaptor(self) -> org.antlr.runtime.tree.TreeAdaptor: ...
    
    def getTreeSource(self) -> object: ...
    
    def index(self) -> int: ...
    
    def mark(self) -> int: ...
    
    def release(self, i: int) -> None: ...
    
    def replaceChildren(self, o: object, i: int, i2: int, o2: object) -> None: ...
    
    def reset(self) -> None: ...
    
    def rewind(self) -> None: ...
    
    def seek(self, i: int) -> None: ...
    
    def setDebugListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    def setUniqueNavigationNodes(self, b: bool) -> None: ...
    
    def size(self) -> int: ...
    
    
class DebugTreeParser(org.antlr.runtime.tree.TreeParser):
    DEFAULT_TOKEN_CHANNEL = 0
    DOWN = 2
    HIDDEN = 99
    INITIAL_FOLLOW_STACK_SIZE = 100
    MEMO_RULE_FAILED = -2
    MEMO_RULE_UNKNOWN = -1
    NEXT_TOKEN_RULE_NAME = u'nextToken'
    UP = 3
    isCyclicDecision: bool
    
    def __init__(self, o: org.antlr.runtime.tree.TreeNodeStream, o2: org.antlr.runtime.RecognizerSharedState) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def beginResync(self) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def endResync(self) -> None: ...
    
    def getDebugListener(self) -> DebugEventListener: ...
    
    def reportError(self, j: java.io.IOException) -> None: ...
    
    def setDebugListener(self, debugEventListener: DebugEventListener) -> None: ...
    
    
class ParseTreeBuilder(BlankDebugEventListener):
    EPSILON_PAYLOAD = u'<epsilon>'
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def __init__(self, s: str) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def create(self, o: object) -> org.antlr.runtime.tree.ParseTree: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def epsilonNode(self) -> org.antlr.runtime.tree.ParseTree: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def getTree(self) -> org.antlr.runtime.tree.ParseTree: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    
class Profiler(BlankDebugEventListener):
    FALSE = 0
    NUM_RUNTIME_STATS = 29
    PROTOCOL_VERSION = u'2'
    RUNTIME_STATS_FILENAME = u'runtime.stats'
    TRUE = 1
    Version = u'2'
    decisionMaxCyclicLookaheads: typing.List[int]
    decisionMaxFixedLookaheads: typing.List[int]
    decisionMaxSynPredLookaheads: list
    maxRuleInvocationDepth: int
    numBacktrackDecisions: int
    numCharsMatched: int
    numCyclicDecisions: int
    numFixedDecisions: int
    numGuessingRuleInvocations: int
    numHiddenCharsMatched: int
    numHiddenTokens: int
    numMemoizationCacheEntries: int
    numMemoizationCacheHits: int
    numMemoizationCacheMisses: int
    numRuleInvocations: int
    numSemanticPredicates: int
    numSyntacticPredicates: int
    parser: DebugParser
    
    def LT(self, i: int, o: org.antlr.runtime.Token) -> None: ...
    
    def __init__(self) -> None: ...
    
    def beginBacktrack(self, i: int) -> None: ...
    
    def consumeHiddenToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def consumeToken(self, o: org.antlr.runtime.Token) -> None: ...
    
    def endBacktrack(self, i: int, b: bool) -> None: ...
    
    def enterDecision(self, i: int) -> None: ...
    
    def enterRule(self, s: str, s2: str) -> None: ...
    
    def examineRuleMemoization(self, o: org.antlr.runtime.IntStream, i: int, s: str) -> None: ...
    
    def exitDecision(self, i: int) -> None: ...
    
    def exitRule(self, s: str, s2: str) -> None: ...
    
    def getNumberOfHiddenTokens(self, i: int, i2: int) -> int: ...
    
    def inDecision(self) -> bool: ...
    
    def memoize(self, o: org.antlr.runtime.IntStream, i: int, i2: int, s: str) -> None: ...
    
    def recognitionException(self, o: org.antlr.runtime.RecognitionException) -> None: ...
    
    def semanticPredicate(self, b: bool, s: str) -> None: ...
    
    def setParser(self, debugParser: DebugParser) -> None: ...
    
    def terminate(self) -> None: ...
    
    def toNotifyString(self) -> str: ...
    
    def toString(self) -> str: ...
    
    
class RemoteDebugEventSocketListener(java.lang.Runnable):
    grammarFileName: str
    version: str
    
    def __init__(self, debugEventListener: DebugEventListener, s: str, i: int) -> None: ...
    
    def getEventElements(self, s: str) -> typing.List[str]: ...
    
    def run(self) -> None: ...
    
    def start(self) -> None: ...
    
    def tokenIndexesAreInvalid(self) -> bool: ...
    
    
    class ProxyToken:
        DEFAULT_CHANNEL = 0
        DOWN = 2
        EOF = -1
        EOF_TOKEN = "[@-1,0:0='<no text>',<-1>,0:-1]"
        EOR_TOKEN_TYPE = 1
        HIDDEN_CHANNEL = 99
        INVALID_TOKEN = "[@-1,0:0='<no text>',<0>,0:-1]"
        INVALID_TOKEN_TYPE = 0
        MIN_TOKEN_TYPE = 4
        SKIP_TOKEN = "[@-1,0:0='<no text>',<0>,0:-1]"
        UP = 3
        
        def __init__(self, i: int) -> None: ...
        
        def getChannel(self) -> int: ...
        
        def getCharPositionInLine(self) -> int: ...
        
        def getInputStream(self) -> org.antlr.runtime.CharStream: ...
        
        def getLine(self) -> int: ...
        
        def getText(self) -> str: ...
        
        def getTokenIndex(self) -> int: ...
        
        def getType(self) -> int: ...
        
        def setChannel(self, i: int) -> None: ...
        
        def setCharPositionInLine(self, i: int) -> None: ...
        
        def setInputStream(self, o: org.antlr.runtime.CharStream) -> None: ...
        
        def setLine(self, i: int) -> None: ...
        
        def setText(self, s: str) -> None: ...
        
        def setTokenIndex(self, i: int) -> None: ...
        
        def setType(self, i: int) -> None: ...
        
        def toString(self) -> str: ...
        
        
    class ProxyTree:
        ID: int
        INVALID_NODE = '<errornode>'
        charPos: int
        line: int
        text: str
        tokenIndex: int
        type: int
        
        def __init__(self, i: int) -> None: ...
        
        def dupNode(self) -> org.antlr.runtime.tree.Tree: ...
        
        def getText(self) -> str: ...
        
        def getTokenStartIndex(self) -> int: ...
        
        def getTokenStopIndex(self) -> int: ...
        
        def getType(self) -> int: ...
        
        def setTokenStartIndex(self, i: int) -> None: ...
        
        def setTokenStopIndex(self, i: int) -> None: ...
        
        def toString(self) -> str: ...
        
        
    
class TraceDebugEventListener(BlankDebugEventListener):
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    
    def __init__(self, o: org.antlr.runtime.tree.TreeAdaptor) -> None: ...
    
    def addChild(self, o: object, o2: object) -> None: ...
    
    def becomeRoot(self, o: object, o2: object) -> None: ...
    
    def consumeNode(self, o: object) -> None: ...
    
    def createNode(self, o: object) -> None: ...
    
    def enterRule(self, s: str) -> None: ...
    
    def enterSubRule(self, i: int) -> None: ...
    
    def exitRule(self, s: str) -> None: ...
    
    def exitSubRule(self, i: int) -> None: ...
    
    def location(self, i: int, i2: int) -> None: ...
    
    def nilNode(self, o: object) -> None: ...
    
    def setTokenBoundaries(self, o: object, i: int, i2: int) -> None: ...
    
    
class Tracer(BlankDebugEventListener):
    FALSE = 0
    PROTOCOL_VERSION = u'2'
    TRUE = 1
    input: org.antlr.runtime.IntStream
    
    def __init__(self, o: org.antlr.runtime.IntStream) -> None: ...
    
    def enterRule(self, s: str) -> None: ...
    
    def exitRule(self, s: str) -> None: ...
    
    def getInputSymbol(self, i: int) -> object: ...
    
    

import typing
import java.io
import java.nio.channels
import java.util
import java.util.concurrent
import java.util.stream

R = typing.TypeVar("R")
T = typing.TypeVar("T")


class Throwable:
    def __init__(self) -> None: ...
    
    def addSuppressed(self, throwable: 'Throwable') -> None: ...
    
    def fillInStackTrace(self) -> 'Throwable': ...
    
    def getCause(self) -> 'Throwable': ...
    
    def getLocalizedMessage(self) -> str: ...
    
    def getMessage(self) -> str: ...
    
    def getStackTrace(self) -> typing.List['StackTraceElement']: ...
    
    def getSuppressed(self) -> typing.List['Throwable']: ...
    
    def initCause(self, throwable: 'Throwable') -> 'Throwable': ...
    
    def printStackTrace(self) -> None: ...
    
    def setStackTrace(self, t: typing.List['StackTraceElement']) -> None: ...
    
    def toString(self) -> str: ...
    
    
class Exception(Throwable):
    def __init__(self) -> None: ...
    
    
class RuntimeException(Exception):
    def __init__(self) -> None: ...
    
    
class IllegalArgumentException(RuntimeException):
    def __init__(self) -> None: ...
    
    
class IllegalThreadStateException(IllegalArgumentException):
    def __init__(self) -> None: ...
    
    
class Object(object):
    def __init__(self) -> None: ...
    
    def equals(self, o: object) -> bool: ...
    
    def getClass(self) -> typing.Any: ...
    
    def hashCode(self) -> int: ...
    
    def notify(self) -> None: ...
    
    def notifyAll(self) -> None: ...
    
    def toString(self) -> str: ...
    
    def wait(self) -> None: ...
    
    
class Number(Object, java.io.Serializable):
    def __init__(self) -> None: ...
    
    def byteValue(self) -> int: ...
    
    def doubleValue(self) -> float: ...
    
    def floatValue(self) -> float: ...
    
    def intValue(self) -> int: ...
    
    def longValue(self) -> int: ...
    
    def shortValue(self) -> int: ...
    
    
class Comparable(Object):
    def __init__(self) -> None: ...
    
    def compareTo(self, t: 'T') -> int: ...
    
    
class Integer(Number, Comparable, 'constant.Constable', 'constant.ConstantDesc'):
    BYTES = 4
    MAX_VALUE = 2147483647
    MIN_VALUE = -2147483648
    SIZE = 32
    
    def __init__(self, i: int) -> None: ...
    
    @staticmethod
    def bitCount(i: int) -> int: ...
    
    def byteValue(self) -> int: ...
    
    @staticmethod
    def compare(i: int, i2: int) -> int: ...
    
    def compareTo(self, i: int) -> int: ...
    
    @staticmethod
    def compareUnsigned(i: int, i2: int) -> int: ...
    
    @staticmethod
    def compress(i: int, i2: int) -> int: ...
    
    @staticmethod
    def decode(s: str) -> int: ...
    
    def describeConstable(self) -> typing.Any: ...
    
    @staticmethod
    def divideUnsigned(i: int, i2: int) -> int: ...
    
    def doubleValue(self) -> float: ...
    
    def equals(self, o: object) -> bool: ...
    
    @staticmethod
    def expand(i: int, i2: int) -> int: ...
    
    def floatValue(self) -> float: ...
    
    @staticmethod
    def getInteger(s: str) -> int: ...
    
    def hashCode(self) -> int: ...
    
    @staticmethod
    def highestOneBit(i: int) -> int: ...
    
    def intValue(self) -> int: ...
    
    def longValue(self) -> int: ...
    
    @staticmethod
    def lowestOneBit(i: int) -> int: ...
    
    @staticmethod
    def max(i: int, i2: int) -> int: ...
    
    @staticmethod
    def min(i: int, i2: int) -> int: ...
    
    @staticmethod
    def numberOfLeadingZeros(i: int) -> int: ...
    
    @staticmethod
    def numberOfTrailingZeros(i: int) -> int: ...
    
    @staticmethod
    def parseInt(s: str) -> int: ...
    
    @staticmethod
    def parseUnsignedInt(s: str) -> int: ...
    
    @staticmethod
    def remainderUnsigned(i: int, i2: int) -> int: ...
    
    def resolveConstantDesc(self, s: str) -> int: ...
    
    @staticmethod
    def reverse(i: int) -> int: ...
    
    @staticmethod
    def reverseBytes(i: int) -> int: ...
    
    @staticmethod
    def rotateLeft(i: int, i2: int) -> int: ...
    
    @staticmethod
    def rotateRight(i: int, i2: int) -> int: ...
    
    def shortValue(self) -> int: ...
    
    @staticmethod
    def signum(i: int) -> int: ...
    
    @staticmethod
    def sum(i: int, i2: int) -> int: ...
    
    @staticmethod
    def toBinaryString(i: int) -> str: ...
    
    @staticmethod
    def toHexString(i: int) -> str: ...
    
    @staticmethod
    def toOctalString(i: int) -> str: ...
    
    def toString(self) -> str: ...
    
    @staticmethod
    def toUnsignedLong(i: int) -> int: ...
    
    @staticmethod
    def toUnsignedString(i: int) -> str: ...
    
    @staticmethod
    def valueOf(i: int) -> int: ...
    
    
class InterruptedException(Exception):
    def __init__(self) -> None: ...
    
    
class Process(Object):
    def __init__(self) -> None: ...
    
    def children(self) -> typing.Any: ...
    
    def descendants(self) -> typing.Any: ...
    
    def destroy(self) -> None: ...
    
    def destroyForcibly(self) -> 'Process': ...
    
    def errorReader(self) -> java.io.BufferedReader: ...
    
    def exitValue(self) -> int: ...
    
    def getErrorStream(self) -> java.io.InputStream: ...
    
    def getInputStream(self) -> java.io.InputStream: ...
    
    def getOutputStream(self) -> java.io.OutputStream: ...
    
    def info(self) -> str: ...
    
    def inputReader(self) -> java.io.BufferedReader: ...
    
    def isAlive(self) -> bool: ...
    
    def onExit(self) -> typing.Any: ...
    
    def outputWriter(self) -> java.io.BufferedWriter: ...
    
    def pid(self) -> int: ...
    
    def supportsNormalTermination(self) -> bool: ...
    
    def toHandle(self) -> 'ProcessHandle': ...
    
    def waitFor(self) -> int: ...
    
    
class ProcessBuilder(Object):
    def __init__(self, t: typing.List[str]) -> None: ...
    
    def command(self) -> typing.List[str]: ...
    
    def directory(self) -> java.io.File: ...
    
    def environment(self) -> typing.Dict[str,str]: ...
    
    def inheritIO(self) -> 'ProcessBuilder': ...
    
    def redirectError(self) -> str: ...
    
    def redirectErrorStream(self) -> bool: ...
    
    def redirectInput(self) -> str: ...
    
    def redirectOutput(self) -> str: ...
    
    def start(self) -> Process: ...
    
    @staticmethod
    def startPipeline(t: typing.List['ProcessBuilder']) -> typing.List[Process]: ...
    
    
    class Redirect:
        DISCARD = 'WRITE'
        INHERIT = 'INHERIT'
        PIPE = 'PIPE'
        
        def __init__(self) -> None: ...
        
        @staticmethod
        def appendTo(j: java.io.File) -> str: ...
        
        def equals(self, o: object) -> bool: ...
        
        def file(self) -> java.io.File: ...
        
        @staticmethod
        def from(j: java.io.File) -> str: ...
        
        def hashCode(self) -> int: ...
        
        @staticmethod
        def to(j: java.io.File) -> str: ...
        
        def type(self) -> str: ...
        
        
        class Type:
            APPEND = 'APPEND'
            INHERIT = 'INHERIT'
            PIPE = 'PIPE'
            READ = 'READ'
            WRITE = 'WRITE'
            
            def __init__(self) -> None: ...
            
            @staticmethod
            def valueOf(s: str) -> str: ...
            
            @staticmethod
            def values() -> typing.List[str]: ...
            
            
        
    
class Runnable(Object):
    def __init__(self) -> None: ...
    
    def run(self) -> None: ...
    
    
class SecurityException(RuntimeException):
    def __init__(self) -> None: ...
    
    
class CharSequence(Object):
    def __init__(self) -> None: ...
    
    def charAt(self, i: int) -> str: ...
    
    def chars(self) -> java.util.stream.IntStream: ...
    
    def codePoints(self) -> java.util.stream.IntStream: ...
    
    @staticmethod
    def compare(charSequence: 'CharSequence', charSequence2: 'CharSequence') -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def length(self) -> int: ...
    
    def subSequence(self, i: int, i2: int) -> 'CharSequence': ...
    
    def toString(self) -> str: ...
    
    
class String(Object, Comparable, CharSequence, java.io.Serializable, 'constant.Constable', 'constant.ConstantDesc'):
    CASE_INSENSITIVE_ORDER = 'java.lang.String$CaseInsensitiveComparator'
    
    def __init__(self) -> None: ...
    
    def charAt(self, i: int) -> str: ...
    
    def chars(self) -> java.util.stream.IntStream: ...
    
    def codePointAt(self, i: int) -> int: ...
    
    def codePointBefore(self, i: int) -> int: ...
    
    def codePointCount(self, i: int, i2: int) -> int: ...
    
    def codePoints(self) -> java.util.stream.IntStream: ...
    
    def compareTo(self, s: str) -> int: ...
    
    def compareToIgnoreCase(self, s: str) -> int: ...
    
    def concat(self, s: str) -> str: ...
    
    def contains(self, charSequence: CharSequence) -> bool: ...
    
    def contentEquals(self, stringBuffer: 'StringBuffer') -> bool: ...
    
    @staticmethod
    def copyValueOf(t: typing.List[str]) -> str: ...
    
    def describeConstable(self) -> typing.Any: ...
    
    def endsWith(self, s: str) -> bool: ...
    
    def equals(self, o: object) -> bool: ...
    
    def equalsIgnoreCase(self, s: str) -> bool: ...
    
    @staticmethod
    def format(s: str, t: typing.List[object]) -> str: ...
    
    def formatted(self, t: typing.List[object]) -> str: ...
    
    def getBytes(self) -> typing.List[int]: ...
    
    def getChars(self, i: int, i2: int, t: typing.List[str], i3: int) -> None: ...
    
    def hashCode(self) -> int: ...
    
    def indent(self, i: int) -> str: ...
    
    def indexOf(self, i: int) -> int: ...
    
    def intern(self) -> str: ...
    
    def isBlank(self) -> bool: ...
    
    def isEmpty(self) -> bool: ...
    
    @staticmethod
    def join(charSequence: CharSequence, t: typing.List[CharSequence]) -> str: ...
    
    def lastIndexOf(self, i: int) -> int: ...
    
    def length(self) -> int: ...
    
    def lines(self) -> typing.Any: ...
    
    def matches(self, s: str) -> bool: ...
    
    def offsetByCodePoints(self, i: int, i2: int) -> int: ...
    
    def regionMatches(self, i: int, s: str, i2: int, i3: int) -> bool: ...
    
    def repeat(self, i: int) -> str: ...
    
    def replace(self, s: str, s2: str) -> str: ...
    
    def replaceAll(self, s: str, s2: str) -> str: ...
    
    def replaceFirst(self, s: str, s2: str) -> str: ...
    
    def resolveConstantDesc(self, s: str) -> object: ...
    
    def split(self, s: str) -> typing.List[str]: ...
    
    def splitWithDelimiters(self, s: str, i: int) -> typing.List[str]: ...
    
    def startsWith(self, s: str) -> bool: ...
    
    def strip(self) -> str: ...
    
    def stripIndent(self) -> str: ...
    
    def stripLeading(self) -> str: ...
    
    def stripTrailing(self) -> str: ...
    
    def subSequence(self, i: int, i2: int) -> CharSequence: ...
    
    def substring(self, i: int) -> str: ...
    
    def toCharArray(self) -> typing.List[str]: ...
    
    def toLowerCase(self) -> str: ...
    
    def toString(self) -> str: ...
    
    def toUpperCase(self) -> str: ...
    
    def transform(self, t: typing.Any) -> 'R': ...
    
    def translateEscapes(self) -> str: ...
    
    def trim(self) -> str: ...
    
    @staticmethod
    def valueOf(i: int) -> str: ...
    
    
class Appendable:
    def __init__(self) -> None: ...
    
    def append(self, s: str) -> 'Appendable': ...
    
    
class AbstractStringBuilder(Object, Appendable, CharSequence):
    def __init__(self) -> None: ...
    
    
class StringBuilder(AbstractStringBuilder, Comparable, java.io.Serializable):
    def __init__(self) -> None: ...
    
    def append(self, i: int) -> AbstractStringBuilder: ...
    
    def appendCodePoint(self, i: int) -> AbstractStringBuilder: ...
    
    def capacity(self) -> int: ...
    
    def charAt(self, i: int) -> str: ...
    
    def chars(self) -> java.util.stream.IntStream: ...
    
    def codePointAt(self, i: int) -> int: ...
    
    def codePointBefore(self, i: int) -> int: ...
    
    def codePointCount(self, i: int, i2: int) -> int: ...
    
    def codePoints(self) -> java.util.stream.IntStream: ...
    
    def compareTo(self, stringBuilder: 'StringBuilder') -> int: ...
    
    def delete(self, i: int, i2: int) -> 'StringBuilder': ...
    
    def deleteCharAt(self, i: int) -> 'StringBuilder': ...
    
    def ensureCapacity(self, i: int) -> None: ...
    
    def getChars(self, i: int, i2: int, t: typing.List[str], i3: int) -> None: ...
    
    def indexOf(self, s: str) -> int: ...
    
    def insert(self, i: int, i2: int) -> 'StringBuilder': ...
    
    def lastIndexOf(self, s: str) -> int: ...
    
    def length(self) -> int: ...
    
    def offsetByCodePoints(self, i: int, i2: int) -> int: ...
    
    def repeat(self, i: int, i2: int) -> AbstractStringBuilder: ...
    
    def replace(self, i: int, i2: int, s: str) -> 'StringBuilder': ...
    
    def reverse(self) -> AbstractStringBuilder: ...
    
    def setCharAt(self, i: int, s: str) -> None: ...
    
    def setLength(self, i: int) -> None: ...
    
    def subSequence(self, i: int, i2: int) -> CharSequence: ...
    
    def substring(self, i: int) -> str: ...
    
    def toString(self) -> str: ...
    
    def trimToSize(self) -> None: ...
    
    
class System(Object):
    err = 'java.io.PrintStream'
    in = 'java.io.BufferedInputStream'
    out = 'java.io.PrintStream'
    
    @typing.overload
    @staticmethod
    def getProperty(key: str, default: str) -> str: ...
    
    def __init__(self) -> None: ...
    
    @staticmethod
    def arraycopy(o: object, i: int, o2: object, i2: int, i3: int) -> None: ...
    
    @staticmethod
    def clearProperty(s: str) -> str: ...
    
    @staticmethod
    def console() -> java.io.Console: ...
    
    @staticmethod
    def currentTimeMillis() -> int: ...
    
    @staticmethod
    def exit(i: int) -> None: ...
    
    @staticmethod
    def gc() -> None: ...
    
    @staticmethod
    def getLogger(s: str) -> str: ...
    
    @staticmethod
    def getProperties() -> java.util.Properties: ...
    
    @staticmethod
    def getProperty(s: str) -> str: ...
    
    @staticmethod
    def getSecurityManager() -> 'SecurityManager': ...
    
    @staticmethod
    def getenv() -> typing.Dict[str,str]: ...
    
    @staticmethod
    def identityHashCode(o: object) -> int: ...
    
    @staticmethod
    def inheritedChannel() -> java.nio.channels.Channel: ...
    
    @staticmethod
    def lineSeparator() -> str: ...
    
    @staticmethod
    def load(s: str) -> None: ...
    
    @staticmethod
    def loadLibrary(s: str) -> None: ...
    
    @staticmethod
    def mapLibraryName(s: str) -> str: ...
    
    @staticmethod
    def nanoTime() -> int: ...
    
    @staticmethod
    def runFinalization() -> None: ...
    
    @staticmethod
    def setErr(j: java.io.PrintStream) -> None: ...
    
    @staticmethod
    def setIn(j: java.io.InputStream) -> None: ...
    
    @staticmethod
    def setOut(j: java.io.PrintStream) -> None: ...
    
    @staticmethod
    def setProperties(j: java.util.Properties) -> None: ...
    
    @staticmethod
    def setProperty(s: str, s2: str) -> str: ...
    
    @staticmethod
    def setSecurityManager(securityManager: 'SecurityManager') -> None: ...
    
    
    class Logger:
        def __init__(self) -> None: ...
        
        def getName(self) -> str: ...
        
        def isLoggable(self, s: str) -> bool: ...
        
        def log(self, s: str, s2: str) -> None: ...
        
        
        class Level:
            ALL = 'ALL'
            DEBUG = 'DEBUG'
            ERROR = 'ERROR'
            INFO = 'INFO'
            OFF = 'OFF'
            TRACE = 'TRACE'
            WARNING = 'WARNING'
            
            def __init__(self) -> None: ...
            
            def getName(self) -> str: ...
            
            def getSeverity(self) -> int: ...
            
            @staticmethod
            def valueOf(s: str) -> str: ...
            
            @staticmethod
            def values() -> typing.List[str]: ...
            
            
        
    class LoggerFinder:
        def __init__(self) -> None: ...
        
        def getLocalizedLogger(self, s: str, j: java.util.ResourceBundle, module: 'Module') -> str: ...
        
        def getLogger(self, s: str, module: 'Module') -> str: ...
        
        @staticmethod
        def getLoggerFinder() -> str: ...
        
        
    
class Thread(Object, Runnable):
    MAX_PRIORITY = 10
    MIN_PRIORITY = 1
    NORM_PRIORITY = 5
    
    def __init__(self) -> None: ...
    
    @staticmethod
    def activeCount() -> int: ...
    
    def checkAccess(self) -> None: ...
    
    def countStackFrames(self) -> int: ...
    
    @staticmethod
    def currentThread() -> 'Thread': ...
    
    @staticmethod
    def dumpStack() -> None: ...
    
    @staticmethod
    def enumerate(t: typing.List['Thread']) -> int: ...
    
    @staticmethod
    def getAllStackTraces() -> typing.Dict['Thread',typing.List['StackTraceElement']]: ...
    
    def getContextClassLoader(self) -> 'ClassLoader': ...
    
    @staticmethod
    def getDefaultUncaughtExceptionHandler() -> str: ...
    
    def getId(self) -> int: ...
    
    def getName(self) -> str: ...
    
    def getPriority(self) -> int: ...
    
    def getStackTrace(self) -> typing.List['StackTraceElement']: ...
    
    def getState(self) -> str: ...
    
    def getThreadGroup(self) -> 'ThreadGroup': ...
    
    def getUncaughtExceptionHandler(self) -> str: ...
    
    @staticmethod
    def holdsLock(o: object) -> bool: ...
    
    def interrupt(self) -> None: ...
    
    @staticmethod
    def interrupted() -> bool: ...
    
    def isAlive(self) -> bool: ...
    
    def isDaemon(self) -> bool: ...
    
    def isInterrupted(self) -> bool: ...
    
    def isVirtual(self) -> bool: ...
    
    def join(self) -> None: ...
    
    @staticmethod
    def ofPlatform() -> str: ...
    
    @staticmethod
    def ofVirtual() -> str: ...
    
    @staticmethod
    def onSpinWait() -> None: ...
    
    def resume(self) -> None: ...
    
    def run(self) -> None: ...
    
    def setContextClassLoader(self, classLoader: 'ClassLoader') -> None: ...
    
    def setDaemon(self, b: bool) -> None: ...
    
    @staticmethod
    def setDefaultUncaughtExceptionHandler(s: str) -> None: ...
    
    def setName(self, s: str) -> None: ...
    
    def setPriority(self, i: int) -> None: ...
    
    def setUncaughtExceptionHandler(self, s: str) -> None: ...
    
    @staticmethod
    def sleep(i: int) -> None: ...
    
    def start(self) -> None: ...
    
    @staticmethod
    def startVirtualThread(runnable: Runnable) -> 'Thread': ...
    
    def stop(self) -> None: ...
    
    def suspend(self) -> None: ...
    
    def threadId(self) -> int: ...
    
    def toString(self) -> str: ...
    
    @staticmethod
    def yield() -> None: ...
    
    
    class Builder:
        def __init__(self) -> None: ...
        
        def factory(self) -> java.util.concurrent.ThreadFactory: ...
        
        def inheritInheritableThreadLocals(self, b: bool) -> str: ...
        
        def name(self, s: str) -> str: ...
        
        def start(self, runnable: Runnable) -> 'Thread': ...
        
        def uncaughtExceptionHandler(self, s: str) -> str: ...
        
        def unstarted(self, runnable: Runnable) -> 'Thread': ...
        
        
        class OfPlatform:
            def __init__(self) -> None: ...
            
            def daemon(self) -> str: ...
            
            def group(self, threadGroup: 'ThreadGroup') -> str: ...
            
            def inheritInheritableThreadLocals(self, b: bool) -> str: ...
            
            def name(self, s: str) -> str: ...
            
            def priority(self, i: int) -> str: ...
            
            def stackSize(self, i: int) -> str: ...
            
            def uncaughtExceptionHandler(self, s: str) -> str: ...
            
            
        class OfVirtual:
            def __init__(self) -> None: ...
            
            def inheritInheritableThreadLocals(self, b: bool) -> str: ...
            
            def name(self, s: str) -> str: ...
            
            def uncaughtExceptionHandler(self, s: str) -> str: ...
            
            
        
    class State:
        BLOCKED = 'BLOCKED'
        NEW = 'NEW'
        RUNNABLE = 'RUNNABLE'
        TERMINATED = 'TERMINATED'
        TIMED_WAITING = 'TIMED_WAITING'
        WAITING = 'WAITING'
        
        def __init__(self) -> None: ...
        
        @staticmethod
        def valueOf(s: str) -> str: ...
        
        @staticmethod
        def values() -> typing.List[str]: ...
        
        
    class UncaughtExceptionHandler:
        def __init__(self) -> None: ...
        
        def uncaughtException(self, thread: 'Thread', throwable: Throwable) -> None: ...
        
        
    

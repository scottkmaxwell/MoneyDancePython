import typing
import java.lang
import java.util
import java.util.function

R = typing.TypeVar("R")
S = typing.TypeVar("S")
T = typing.TypeVar("T")


class BaseStream(java.lang.AutoCloseable):
    def __init__(self) -> None: ...
    
    def close(self) -> None: ...
    
    def isParallel(self) -> bool: ...
    
    def iterator(self) -> typing.Iterator['T']: ...
    
    def onClose(self, j: java.lang.Runnable) -> 'S': ...
    
    def parallel(self) -> 'S': ...
    
    def sequential(self) -> 'S': ...
    
    def spliterator(self) -> typing.Any: ...
    
    def unordered(self) -> 'S': ...
    
    
class IntStream(BaseStream):
    def __init__(self) -> None: ...
    
    def allMatch(self, j: java.util.function.IntPredicate) -> bool: ...
    
    def anyMatch(self, j: java.util.function.IntPredicate) -> bool: ...
    
    def asDoubleStream(self) -> 'DoubleStream': ...
    
    def asLongStream(self) -> 'LongStream': ...
    
    def average(self) -> java.util.OptionalDouble: ...
    
    def boxed(self) -> typing.Any: ...
    
    @staticmethod
    def builder() -> str: ...
    
    def collect(self, t: typing.Any, t2: typing.Any, t3: typing.Any) -> 'R': ...
    
    @staticmethod
    def concat(intStream: 'IntStream', intStream2: 'IntStream') -> 'IntStream': ...
    
    def count(self) -> int: ...
    
    def distinct(self) -> 'IntStream': ...
    
    def dropWhile(self, j: java.util.function.IntPredicate) -> 'IntStream': ...
    
    @staticmethod
    def empty() -> 'IntStream': ...
    
    def filter(self, j: java.util.function.IntPredicate) -> 'IntStream': ...
    
    def findAny(self) -> java.util.OptionalInt: ...
    
    def findFirst(self) -> java.util.OptionalInt: ...
    
    def flatMap(self, t: typing.Any) -> 'IntStream': ...
    
    def forEach(self, j: java.util.function.IntConsumer) -> None: ...
    
    def forEachOrdered(self, j: java.util.function.IntConsumer) -> None: ...
    
    @staticmethod
    def generate(j: java.util.function.IntSupplier) -> 'IntStream': ...
    
    @staticmethod
    def iterate(i: int, j: java.util.function.IntUnaryOperator) -> 'IntStream': ...
    
    def iterator(self) -> typing.Iterator: ...
    
    def limit(self, i: int) -> 'IntStream': ...
    
    def map(self, j: java.util.function.IntUnaryOperator) -> 'IntStream': ...
    
    def mapMulti(self, s: str) -> 'IntStream': ...
    
    def mapToDouble(self, j: java.util.function.IntToDoubleFunction) -> 'DoubleStream': ...
    
    def mapToLong(self, j: java.util.function.IntToLongFunction) -> 'LongStream': ...
    
    def mapToObj(self, t: typing.Any) -> typing.Any: ...
    
    def max(self) -> java.util.OptionalInt: ...
    
    def min(self) -> java.util.OptionalInt: ...
    
    def noneMatch(self, j: java.util.function.IntPredicate) -> bool: ...
    
    @staticmethod
    def of(i: int) -> 'IntStream': ...
    
    def parallel(self) -> BaseStream: ...
    
    def peek(self, j: java.util.function.IntConsumer) -> 'IntStream': ...
    
    @staticmethod
    def range(i: int, i2: int) -> 'IntStream': ...
    
    @staticmethod
    def rangeClosed(i: int, i2: int) -> 'IntStream': ...
    
    def reduce(self, j: java.util.function.IntBinaryOperator) -> java.util.OptionalInt: ...
    
    def sequential(self) -> BaseStream: ...
    
    def skip(self, i: int) -> 'IntStream': ...
    
    def sorted(self) -> 'IntStream': ...
    
    def spliterator(self) -> java.util.Spliterator: ...
    
    def sum(self) -> int: ...
    
    def summaryStatistics(self) -> java.util.IntSummaryStatistics: ...
    
    def takeWhile(self, j: java.util.function.IntPredicate) -> 'IntStream': ...
    
    def toArray(self) -> typing.List[int]: ...
    
    
    class Builder:
        def __init__(self) -> None: ...
        
        def accept(self, i: int) -> None: ...
        
        def add(self, i: int) -> str: ...
        
        def build(self) -> 'IntStream': ...
        
        
    class IntMapMultiConsumer:
        def __init__(self) -> None: ...
        
        def accept(self, i: int, j: java.util.function.IntConsumer) -> None: ...
        
        
    

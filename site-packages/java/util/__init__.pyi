import typing
import java.io
import java.lang
import java.time

E = typing.TypeVar("E")
K = typing.TypeVar("K")
T = typing.TypeVar("T")
V = typing.TypeVar("V")


class Calendar(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable):
    ALL_STYLES = 0
    AM = 0
    AM_PM = 9
    APRIL = 3
    AUGUST = 7
    DATE = 5
    DAY_OF_MONTH = 5
    DAY_OF_WEEK = 7
    DAY_OF_WEEK_IN_MONTH = 8
    DAY_OF_YEAR = 6
    DECEMBER = 11
    DST_OFFSET = 16
    ERA = 0
    FEBRUARY = 1
    FIELD_COUNT = 17
    FRIDAY = 6
    HOUR = 10
    HOUR_OF_DAY = 11
    JANUARY = 0
    JULY = 6
    JUNE = 5
    LONG = 2
    LONG_FORMAT = 2
    LONG_STANDALONE = 32770
    MARCH = 2
    MAY = 4
    MILLISECOND = 14
    MINUTE = 12
    MONDAY = 2
    MONTH = 2
    NARROW_FORMAT = 4
    NARROW_STANDALONE = 32772
    NOVEMBER = 10
    OCTOBER = 9
    PM = 1
    SATURDAY = 7
    SECOND = 13
    SEPTEMBER = 8
    SHORT = 1
    SHORT_FORMAT = 1
    SHORT_STANDALONE = 32769
    SUNDAY = 1
    THURSDAY = 5
    TUESDAY = 3
    UNDECIMBER = 12
    WEDNESDAY = 4
    WEEK_OF_MONTH = 4
    WEEK_OF_YEAR = 3
    YEAR = 1
    ZONE_OFFSET = 15
    
    def __init__(self) -> None: ...
    
    def add(self, i: int, i2: int) -> None: ...
    
    def after(self, o: object) -> bool: ...
    
    def before(self, o: object) -> bool: ...
    
    def clear(self) -> None: ...
    
    def clone(self) -> object: ...
    
    def compareTo(self, calendar: 'Calendar') -> int: ...
    
    def equals(self, o: object) -> bool: ...
    
    def get(self, i: int) -> int: ...
    
    def getActualMaximum(self, i: int) -> int: ...
    
    def getActualMinimum(self, i: int) -> int: ...
    
    @staticmethod
    def getAvailableCalendarTypes() -> typing.Set[str]: ...
    
    @staticmethod
    def getAvailableLocales() -> typing.List['Locale']: ...
    
    def getCalendarType(self) -> str: ...
    
    def getDisplayName(self, i: int, i2: int, locale: 'Locale') -> str: ...
    
    def getDisplayNames(self, i: int, i2: int, locale: 'Locale') -> typing.Dict[str,int]: ...
    
    def getFirstDayOfWeek(self) -> int: ...
    
    def getGreatestMinimum(self, i: int) -> int: ...
    
    @staticmethod
    def getInstance() -> 'Calendar': ...
    
    def getLeastMaximum(self, i: int) -> int: ...
    
    def getMaximum(self, i: int) -> int: ...
    
    def getMinimalDaysInFirstWeek(self) -> int: ...
    
    def getMinimum(self, i: int) -> int: ...
    
    def getTime(self) -> 'Date': ...
    
    def getTimeInMillis(self) -> int: ...
    
    def getTimeZone(self) -> 'TimeZone': ...
    
    def getWeekYear(self) -> int: ...
    
    def getWeeksInWeekYear(self) -> int: ...
    
    def hashCode(self) -> int: ...
    
    def isLenient(self) -> bool: ...
    
    def isSet(self, i: int) -> bool: ...
    
    def isWeekDateSupported(self) -> bool: ...
    
    def roll(self, i: int, i2: int) -> None: ...
    
    def set(self, i: int, i2: int) -> None: ...
    
    def setFirstDayOfWeek(self, i: int) -> None: ...
    
    def setLenient(self, b: bool) -> None: ...
    
    def setMinimalDaysInFirstWeek(self, i: int) -> None: ...
    
    def setTime(self, date: 'Date') -> None: ...
    
    def setTimeInMillis(self, i: int) -> None: ...
    
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    
    def setWeekDate(self, i: int, i2: int, i3: int) -> None: ...
    
    def toInstant(self) -> java.time.Instant: ...
    
    def toString(self) -> str: ...
    
    
    class Builder:
        def __init__(self) -> None: ...
        
        def build(self) -> 'Calendar': ...
        
        def set(self, i: int, i2: int) -> str: ...
        
        def setCalendarType(self, s: str) -> str: ...
        
        def setDate(self, i: int, i2: int, i3: int) -> str: ...
        
        def setFields(self, t: typing.List[int]) -> str: ...
        
        def setInstant(self, i: int) -> str: ...
        
        def setLenient(self, b: bool) -> str: ...
        
        def setLocale(self, locale: 'Locale') -> str: ...
        
        def setTimeOfDay(self, i: int, i2: int, i3: int) -> str: ...
        
        def setTimeZone(self, timeZone: 'TimeZone') -> str: ...
        
        def setWeekDate(self, i: int, i2: int, i3: int) -> str: ...
        
        def setWeekDefinition(self, i: int, i2: int) -> str: ...
        
        
    
class Collections:
    EMPTY_LIST = []
    EMPTY_MAP = {}
    EMPTY_SET = []
    
    def __init__(self) -> None: ...
    
    @staticmethod
    def addAll(t: typing.Sequence['T'], t2: typing.List['T']) -> bool: ...
    
    @staticmethod
    def asLifoQueue(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def binarySearch(t: typing.List[typing.Any], t2: 'T') -> int: ...
    
    @staticmethod
    def checkedCollection(t: typing.Sequence['E'], t2: typing.Any) -> typing.Sequence['E']: ...
    
    @staticmethod
    def checkedList(t: typing.List['E'], t2: typing.Any) -> typing.List['E']: ...
    
    @staticmethod
    def checkedMap(t: typing.Dict['K','V'], t2: typing.Any, t3: typing.Any) -> typing.Dict['K','V']: ...
    
    @staticmethod
    def checkedNavigableMap(t: typing.Any, t2: typing.Any, t3: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def checkedNavigableSet(t: typing.Any, t2: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def checkedQueue(t: typing.Any, t2: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def checkedSet(t: typing.Set['E'], t2: typing.Any) -> typing.Set['E']: ...
    
    @staticmethod
    def checkedSortedMap(t: typing.Any, t2: typing.Any, t3: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def checkedSortedSet(t: typing.Any, t2: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def copy(t: typing.List['T'], t2: typing.List['T']) -> None: ...
    
    @staticmethod
    def disjoint(t: typing.Sequence['T'], t2: typing.Sequence['T']) -> bool: ...
    
    @staticmethod
    def emptyEnumeration() -> typing.Any: ...
    
    @staticmethod
    def emptyIterator() -> typing.Iterator['T']: ...
    
    @staticmethod
    def emptyList() -> typing.List['T']: ...
    
    @staticmethod
    def emptyListIterator() -> typing.Any: ...
    
    @staticmethod
    def emptyMap() -> typing.Dict['K','V']: ...
    
    @staticmethod
    def emptyNavigableMap() -> typing.Any: ...
    
    @staticmethod
    def emptyNavigableSet() -> typing.Any: ...
    
    @staticmethod
    def emptySet() -> typing.Set['T']: ...
    
    @staticmethod
    def emptySortedMap() -> typing.Any: ...
    
    @staticmethod
    def emptySortedSet() -> typing.Any: ...
    
    @staticmethod
    def enumeration(t: typing.Sequence['T']) -> typing.Any: ...
    
    @staticmethod
    def fill(t: typing.List['T'], t2: 'T') -> None: ...
    
    @staticmethod
    def frequency(t: typing.Sequence['T'], o: object) -> int: ...
    
    @staticmethod
    def indexOfSubList(t: typing.List['T'], t2: typing.List['T']) -> int: ...
    
    @staticmethod
    def lastIndexOfSubList(t: typing.List['T'], t2: typing.List['T']) -> int: ...
    
    @staticmethod
    def list(t: typing.Any) -> typing.List['T']: ...
    
    @staticmethod
    def max(t: typing.Sequence['T']) -> 'T': ...
    
    @staticmethod
    def min(t: typing.Sequence['T']) -> 'T': ...
    
    @staticmethod
    def nCopies(i: int, t: 'T') -> typing.List['T']: ...
    
    @staticmethod
    def newSequencedSetFromMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def newSetFromMap(t: typing.Dict['E',bool]) -> typing.Set['E']: ...
    
    @staticmethod
    def replaceAll(t: typing.List['T'], t2: 'T', t3: 'T') -> bool: ...
    
    @staticmethod
    def reverse(t: typing.List['T']) -> None: ...
    
    @staticmethod
    def reverseOrder() -> typing.Callable[['T', 'T'], int]: ...
    
    @staticmethod
    def rotate(t: typing.List['T'], i: int) -> None: ...
    
    @staticmethod
    def shuffle(t: typing.List['T']) -> None: ...
    
    @staticmethod
    def singleton(t: 'T') -> typing.Set['T']: ...
    
    @staticmethod
    def singletonList(t: 'T') -> typing.List['T']: ...
    
    @staticmethod
    def singletonMap(k: 'K', v: 'V') -> typing.Dict['K','V']: ...
    
    @staticmethod
    def sort(t: typing.List['T']) -> None: ...
    
    @staticmethod
    def swap(t: typing.List['T'], i: int, i2: int) -> None: ...
    
    @staticmethod
    def synchronizedCollection(t: typing.Sequence['T']) -> typing.Sequence['T']: ...
    
    @staticmethod
    def synchronizedList(t: typing.List['T']) -> typing.List['T']: ...
    
    @staticmethod
    def synchronizedMap(t: typing.Dict['K','V']) -> typing.Dict['K','V']: ...
    
    @staticmethod
    def synchronizedNavigableMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def synchronizedNavigableSet(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def synchronizedSet(t: typing.Set['T']) -> typing.Set['T']: ...
    
    @staticmethod
    def synchronizedSortedMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def synchronizedSortedSet(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableCollection(t: typing.Sequence['T']) -> typing.Sequence['T']: ...
    
    @staticmethod
    def unmodifiableList(t: typing.List['T']) -> typing.List['T']: ...
    
    @staticmethod
    def unmodifiableMap(t: typing.Dict['K','V']) -> typing.Dict['K','V']: ...
    
    @staticmethod
    def unmodifiableNavigableMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableNavigableSet(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableSequencedCollection(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableSequencedMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableSequencedSet(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableSet(t: typing.Set['T']) -> typing.Set['T']: ...
    
    @staticmethod
    def unmodifiableSortedMap(t: typing.Any) -> typing.Any: ...
    
    @staticmethod
    def unmodifiableSortedSet(t: typing.Any) -> typing.Any: ...
    
    
class GregorianCalendar(Calendar):
    AD = 1
    ALL_STYLES = 0
    AM = 0
    AM_PM = 9
    APRIL = 3
    AUGUST = 7
    BC = 0
    DATE = 5
    DAY_OF_MONTH = 5
    DAY_OF_WEEK = 7
    DAY_OF_WEEK_IN_MONTH = 8
    DAY_OF_YEAR = 6
    DECEMBER = 11
    DST_OFFSET = 16
    ERA = 0
    FEBRUARY = 1
    FIELD_COUNT = 17
    FRIDAY = 6
    HOUR = 10
    HOUR_OF_DAY = 11
    JANUARY = 0
    JULY = 6
    JUNE = 5
    LONG = 2
    LONG_FORMAT = 2
    LONG_STANDALONE = 32770
    MARCH = 2
    MAY = 4
    MILLISECOND = 14
    MINUTE = 12
    MONDAY = 2
    MONTH = 2
    NARROW_FORMAT = 4
    NARROW_STANDALONE = 32772
    NOVEMBER = 10
    OCTOBER = 9
    PM = 1
    SATURDAY = 7
    SECOND = 13
    SEPTEMBER = 8
    SHORT = 1
    SHORT_FORMAT = 1
    SHORT_STANDALONE = 32769
    SUNDAY = 1
    THURSDAY = 5
    TUESDAY = 3
    UNDECIMBER = 12
    WEDNESDAY = 4
    WEEK_OF_MONTH = 4
    WEEK_OF_YEAR = 3
    YEAR = 1
    ZONE_OFFSET = 15
    
    def __init__(self) -> None: ...
    
    def add(self, i: int, i2: int) -> None: ...
    
    def clone(self) -> object: ...
    
    def equals(self, o: object) -> bool: ...
    
    @staticmethod
    def from(j: java.time.ZonedDateTime) -> 'GregorianCalendar': ...
    
    def getActualMaximum(self, i: int) -> int: ...
    
    def getActualMinimum(self, i: int) -> int: ...
    
    def getCalendarType(self) -> str: ...
    
    def getGreatestMinimum(self, i: int) -> int: ...
    
    def getGregorianChange(self) -> 'Date': ...
    
    def getLeastMaximum(self, i: int) -> int: ...
    
    def getMaximum(self, i: int) -> int: ...
    
    def getMinimum(self, i: int) -> int: ...
    
    def getTimeZone(self) -> 'TimeZone': ...
    
    def getWeekYear(self) -> int: ...
    
    def getWeeksInWeekYear(self) -> int: ...
    
    def hashCode(self) -> int: ...
    
    def isLeapYear(self, i: int) -> bool: ...
    
    def isWeekDateSupported(self) -> bool: ...
    
    def roll(self, i: int, i2: int) -> None: ...
    
    def setGregorianChange(self, date: 'Date') -> None: ...
    
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    
    def setWeekDate(self, i: int, i2: int, i3: int) -> None: ...
    
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...
    
    
class Collection(typing.Iterable):
    def __init__(self) -> None: ...
    
    def add(self, e: 'E') -> bool: ...
    
    def addAll(self, t: typing.Sequence['E']) -> bool: ...
    
    def clear(self) -> None: ...
    
    def contains(self, o: object) -> bool: ...
    
    def containsAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def equals(self, o: object) -> bool: ...
    
    def hashCode(self) -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def iterator(self) -> typing.Iterator['E']: ...
    
    def parallelStream(self) -> typing.Any: ...
    
    def remove(self, o: object) -> bool: ...
    
    def removeAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def removeIf(self, t: typing.Any) -> bool: ...
    
    def retainAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def size(self) -> int: ...
    
    def spliterator(self) -> typing.Any: ...
    
    def stream(self) -> typing.Any: ...
    
    def toArray(self) -> typing.List[object]: ...
    
    
class SequencedCollection(Collection):
    def __init__(self) -> None: ...
    
    def addFirst(self, e: 'E') -> None: ...
    
    def addLast(self, e: 'E') -> None: ...
    
    def getFirst(self) -> 'E': ...
    
    def getLast(self) -> 'E': ...
    
    def removeFirst(self) -> 'E': ...
    
    def removeLast(self) -> 'E': ...
    
    def reversed(self) -> typing.Any: ...
    
    
class List(SequencedCollection):
    def __init__(self) -> None: ...
    
    def add(self, e: 'E') -> bool: ...
    
    def addAll(self, t: typing.Sequence['E']) -> bool: ...
    
    def addFirst(self, e: 'E') -> None: ...
    
    def addLast(self, e: 'E') -> None: ...
    
    def clear(self) -> None: ...
    
    def contains(self, o: object) -> bool: ...
    
    def containsAll(self, t: typing.Sequence['T']) -> bool: ...
    
    @staticmethod
    def copyOf(t: typing.Sequence['E']) -> typing.List['E']: ...
    
    def equals(self, o: object) -> bool: ...
    
    def get(self, i: int) -> 'E': ...
    
    def getFirst(self) -> 'E': ...
    
    def getLast(self) -> 'E': ...
    
    def hashCode(self) -> int: ...
    
    def indexOf(self, o: object) -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def iterator(self) -> typing.Iterator['E']: ...
    
    def lastIndexOf(self, o: object) -> int: ...
    
    def listIterator(self) -> typing.Any: ...
    
    @staticmethod
    def of() -> typing.List['E']: ...
    
    def removeAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def removeFirst(self) -> 'E': ...
    
    def removeLast(self) -> 'E': ...
    
    def replaceAll(self, t: typing.Any) -> None: ...
    
    def retainAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def reversed(self) -> SequencedCollection: ...
    
    def set(self, i: int, e: 'E') -> 'E': ...
    
    def size(self) -> int: ...
    
    def spliterator(self) -> typing.Any: ...
    
    def subList(self, i: int, i2: int) -> typing.List['E']: ...
    
    def toArray(self) -> typing.List[object]: ...
    
    
class Locale(java.lang.Cloneable, java.io.Serializable):
    CANADA = 'en_CA'
    CANADA_FRENCH = 'fr_CA'
    CHINA = 'zh_CN'
    CHINESE = 'zh'
    ENGLISH = 'en'
    FRANCE = 'fr_FR'
    FRENCH = 'fr'
    GERMAN = 'de'
    GERMANY = 'de_DE'
    ITALIAN = 'it'
    ITALY = 'it_IT'
    JAPAN = 'ja_JP'
    JAPANESE = 'ja'
    KOREA = 'ko_KR'
    KOREAN = 'ko'
    PRC = 'zh_CN'
    PRIVATE_USE_EXTENSION = 'x'
    ROOT = ''
    SIMPLIFIED_CHINESE = 'zh_CN'
    TAIWAN = 'zh_TW'
    TRADITIONAL_CHINESE = 'zh_TW'
    UK = 'en_GB'
    UNICODE_LOCALE_EXTENSION = 'u'
    US = 'en_US'
    
    def __init__(self, s: str) -> None: ...
    
    @staticmethod
    def availableLocales() -> typing.Any: ...
    
    @staticmethod
    def caseFoldLanguageTag(s: str) -> str: ...
    
    def clone(self) -> object: ...
    
    def equals(self, o: object) -> bool: ...
    
    @staticmethod
    def filter(t: typing.List[str], t2: typing.Sequence['Locale']) -> typing.List['Locale']: ...
    
    @staticmethod
    def filterTags(t: typing.List[str], t2: typing.Sequence[str]) -> typing.List[str]: ...
    
    @staticmethod
    def forLanguageTag(s: str) -> 'Locale': ...
    
    @staticmethod
    def getAvailableLocales() -> typing.List['Locale']: ...
    
    def getCountry(self) -> str: ...
    
    @staticmethod
    def getDefault() -> 'Locale': ...
    
    def getDisplayCountry(self) -> str: ...
    
    def getDisplayLanguage(self) -> str: ...
    
    def getDisplayName(self) -> str: ...
    
    def getDisplayScript(self) -> str: ...
    
    def getDisplayVariant(self) -> str: ...
    
    def getExtension(self, s: str) -> str: ...
    
    def getExtensionKeys(self) -> typing.Set[java.lang.Character]: ...
    
    def getISO3Country(self) -> str: ...
    
    def getISO3Language(self) -> str: ...
    
    @staticmethod
    def getISOCountries() -> typing.List[str]: ...
    
    @staticmethod
    def getISOLanguages() -> typing.List[str]: ...
    
    def getLanguage(self) -> str: ...
    
    def getScript(self) -> str: ...
    
    def getUnicodeLocaleAttributes(self) -> typing.Set[str]: ...
    
    def getUnicodeLocaleKeys(self) -> typing.Set[str]: ...
    
    def getUnicodeLocaleType(self, s: str) -> str: ...
    
    def getVariant(self) -> str: ...
    
    def hasExtensions(self) -> bool: ...
    
    def hashCode(self) -> int: ...
    
    @staticmethod
    def lookup(t: typing.List[str], t2: typing.Sequence['Locale']) -> 'Locale': ...
    
    @staticmethod
    def lookupTag(t: typing.List[str], t2: typing.Sequence[str]) -> str: ...
    
    @staticmethod
    def of(s: str) -> 'Locale': ...
    
    @staticmethod
    def setDefault(locale: 'Locale') -> None: ...
    
    def stripExtensions(self) -> 'Locale': ...
    
    def toLanguageTag(self) -> str: ...
    
    def toString(self) -> str: ...
    
    
    class Builder:
        def __init__(self) -> None: ...
        
        def addUnicodeLocaleAttribute(self, s: str) -> str: ...
        
        def build(self) -> 'Locale': ...
        
        def clear(self) -> str: ...
        
        def clearExtensions(self) -> str: ...
        
        def removeUnicodeLocaleAttribute(self, s: str) -> str: ...
        
        def setExtension(self, s: str, s2: str) -> str: ...
        
        def setLanguage(self, s: str) -> str: ...
        
        def setLanguageTag(self, s: str) -> str: ...
        
        def setLocale(self, locale: 'Locale') -> str: ...
        
        def setRegion(self, s: str) -> str: ...
        
        def setScript(self, s: str) -> str: ...
        
        def setUnicodeLocaleKeyword(self, s: str, s2: str) -> str: ...
        
        def setVariant(self, s: str) -> str: ...
        
        
    class Category:
        DISPLAY = 'DISPLAY'
        FORMAT = 'FORMAT'
        
        def __init__(self) -> None: ...
        
        @staticmethod
        def valueOf(s: str) -> str: ...
        
        @staticmethod
        def values() -> typing.List[str]: ...
        
        
    class FilteringMode:
        AUTOSELECT_FILTERING = 'AUTOSELECT_FILTERING'
        EXTENDED_FILTERING = 'EXTENDED_FILTERING'
        IGNORE_EXTENDED_RANGES = 'IGNORE_EXTENDED_RANGES'
        MAP_EXTENDED_RANGES = 'MAP_EXTENDED_RANGES'
        REJECT_EXTENDED_RANGES = 'REJECT_EXTENDED_RANGES'
        
        def __init__(self) -> None: ...
        
        @staticmethod
        def valueOf(s: str) -> str: ...
        
        @staticmethod
        def values() -> typing.List[str]: ...
        
        
    class IsoCountryCode:
        PART1_ALPHA2 = 'PART1_ALPHA2'
        PART1_ALPHA3 = 'PART1_ALPHA3'
        PART3 = 'PART3'
        
        def __init__(self) -> None: ...
        
        @staticmethod
        def valueOf(s: str) -> str: ...
        
        @staticmethod
        def values() -> typing.List[str]: ...
        
        
    class LanguageRange:
        MAX_WEIGHT = 1.0
        MIN_WEIGHT = 0.0
        
        def __init__(self, s: str) -> None: ...
        
        def equals(self, o: object) -> bool: ...
        
        def getRange(self) -> str: ...
        
        def getWeight(self) -> float: ...
        
        def hashCode(self) -> int: ...
        
        @staticmethod
        def mapEquivalents(t: typing.List[str], t2: typing.Dict[str,typing.List[str]]) -> typing.List[str]: ...
        
        @staticmethod
        def parse(s: str) -> typing.List[str]: ...
        
        def toString(self) -> str: ...
        
        
    
class Map:
    def __init__(self) -> None: ...
    
    def clear(self) -> None: ...
    
    def compute(self, k: 'K', t: typing.Any) -> 'V': ...
    
    def computeIfAbsent(self, k: 'K', t: typing.Any) -> 'V': ...
    
    def computeIfPresent(self, k: 'K', t: typing.Any) -> 'V': ...
    
    def containsKey(self, o: object) -> bool: ...
    
    def containsValue(self, o: object) -> bool: ...
    
    @staticmethod
    def copyOf(t: typing.Dict['K','V']) -> typing.Dict['K','V']: ...
    
    @staticmethod
    def entry(k: 'K', v: 'V') -> typing.Any: ...
    
    def entrySet(self) -> typing.Set[typing.Any]: ...
    
    def equals(self, o: object) -> bool: ...
    
    def forEach(self, t: typing.Any) -> None: ...
    
    def fromkeys(self) -> None: ...
    
    def getOrDefault(self, o: object, v: 'V') -> 'V': ...
    
    def hashCode(self) -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def keySet(self) -> typing.Set['K']: ...
    
    def merge(self, k: 'K', v: 'V', t: typing.Any) -> 'V': ...
    
    @staticmethod
    def of() -> typing.Dict['K','V']: ...
    
    @staticmethod
    def ofEntries(t: typing.Any) -> typing.Dict['K','V']: ...
    
    def put(self, k: 'K', v: 'V') -> 'V': ...
    
    def putAll(self, t: typing.Dict['K','V']) -> None: ...
    
    def putIfAbsent(self, k: 'K', v: 'V') -> 'V': ...
    
    def remove(self, o: object) -> 'V': ...
    
    def replace(self, k: 'K', v: 'V') -> 'V': ...
    
    def replaceAll(self, t: typing.Any) -> None: ...
    
    def size(self) -> int: ...
    
    
    class Entry:
        def __init__(self) -> None: ...
        
        @staticmethod
        def comparingByKey() -> typing.Callable[[typing.Any, typing.Any], int]: ...
        
        @staticmethod
        def comparingByValue() -> typing.Callable[[typing.Any, typing.Any], int]: ...
        
        @staticmethod
        def copyOf(t: typing.Any) -> typing.Any: ...
        
        def equals(self, o: object) -> bool: ...
        
        def getKey(self) -> 'K': ...
        
        def getValue(self) -> 'V': ...
        
        def hashCode(self) -> int: ...
        
        def setValue(self, v: 'V') -> 'V': ...
        
        
    
class Set(Collection):
    def __init__(self) -> None: ...
    
    def add(self, e: 'E') -> bool: ...
    
    def addAll(self, t: typing.Sequence['E']) -> bool: ...
    
    def clear(self) -> None: ...
    
    def contains(self, o: object) -> bool: ...
    
    def containsAll(self, t: typing.Sequence['T']) -> bool: ...
    
    @staticmethod
    def copyOf(t: typing.Sequence['E']) -> typing.Set['E']: ...
    
    def equals(self, o: object) -> bool: ...
    
    def hashCode(self) -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def iterator(self) -> typing.Iterator['E']: ...
    
    @staticmethod
    def of() -> typing.Set['E']: ...
    
    def removeAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def retainAll(self, t: typing.Sequence['T']) -> bool: ...
    
    def size(self) -> int: ...
    
    def spliterator(self) -> typing.Any: ...
    
    def toArray(self) -> typing.List[object]: ...
    
    
class TimeZone(java.io.Serializable, java.lang.Cloneable):
    LONG = 1
    SHORT = 0
    
    def __init__(self) -> None: ...
    
    def clone(self) -> object: ...
    
    @staticmethod
    def getAvailableIDs() -> typing.List[str]: ...
    
    def getDSTSavings(self) -> int: ...
    
    @staticmethod
    def getDefault() -> 'TimeZone': ...
    
    def getDisplayName(self) -> str: ...
    
    def getID(self) -> str: ...
    
    def getOffset(self, i: int) -> int: ...
    
    def getRawOffset(self) -> int: ...
    
    @staticmethod
    def getTimeZone(s: str) -> 'TimeZone': ...
    
    def hasSameRules(self, timeZone: 'TimeZone') -> bool: ...
    
    def inDaylightTime(self, date: 'Date') -> bool: ...
    
    def observesDaylightTime(self) -> bool: ...
    
    @staticmethod
    def setDefault(timeZone: 'TimeZone') -> None: ...
    
    def setID(self, s: str) -> None: ...
    
    def setRawOffset(self, i: int) -> None: ...
    
    def toZoneId(self) -> java.time.ZoneId: ...
    
    def useDaylightTime(self) -> bool: ...
    
    
class AbstractMap(Map):
    def __init__(self) -> None: ...
    
    def clear(self) -> None: ...
    
    def containsKey(self, o: object) -> bool: ...
    
    def containsValue(self, o: object) -> bool: ...
    
    def entrySet(self) -> typing.Set[typing.Any]: ...
    
    def equals(self, o: object) -> bool: ...
    
    def fromkeys(self) -> None: ...
    
    def hashCode(self) -> int: ...
    
    def isEmpty(self) -> bool: ...
    
    def keySet(self) -> typing.Set['K']: ...
    
    def put(self, k: 'K', v: 'V') -> 'V': ...
    
    def putAll(self, t: typing.Dict['K','V']) -> None: ...
    
    def remove(self, o: object) -> 'V': ...
    
    def size(self) -> int: ...
    
    def toString(self) -> str: ...
    
    
    class SimpleEntry:
        def __init__(self, t: typing.Any) -> None: ...
        
        def equals(self, o: object) -> bool: ...
        
        def getKey(self) -> 'K': ...
        
        def getValue(self) -> 'V': ...
        
        def hashCode(self) -> int: ...
        
        def setValue(self, v: 'V') -> 'V': ...
        
        def toString(self) -> str: ...
        
        
    class SimpleImmutableEntry:
        def __init__(self, t: typing.Any) -> None: ...
        
        def equals(self, o: object) -> bool: ...
        
        def getKey(self) -> 'K': ...
        
        def getValue(self) -> 'V': ...
        
        def hashCode(self) -> int: ...
        
        def setValue(self, v: 'V') -> 'V': ...
        
        def toString(self) -> str: ...
        
        
    
class WeakHashMap(AbstractMap):
    def __init__(self) -> None: ...
    
    def clear(self) -> None: ...
    
    def containsKey(self, o: object) -> bool: ...
    
    def containsValue(self, o: object) -> bool: ...
    
    def entrySet(self) -> typing.Set[typing.Any]: ...
    
    def forEach(self, t: typing.Any) -> None: ...
    
    def fromkeys(self) -> None: ...
    
    def isEmpty(self) -> bool: ...
    
    def keySet(self) -> typing.Set['K']: ...
    
    @staticmethod
    def newWeakHashMap(i: int) -> typing.Any: ...
    
    def put(self, k: 'K', v: 'V') -> 'V': ...
    
    def putAll(self, t: typing.Dict['K','V']) -> None: ...
    
    def remove(self, o: object) -> 'V': ...
    
    def replaceAll(self, t: typing.Any) -> None: ...
    
    def size(self) -> int: ...
    
    
